{
  "name": "interval-skip-list",
  "version": "2.0.1",
  "description": "A data structure for finding all intervals that overlap a point in O(ln n)",
  "main": "lib/interval-skip-list.js",
  "scripts": {
    "prepublish": "grunt clean lint coffee",
    "test": "grunt test"
  },
  "repository": {
    "type": "git",
    "url": "http://github.com/atom/interval-skip-list.git"
  },
  "bugs": {
    "url": "https://github.com/atom/interval-skip-list/issues"
  },
  "homepage": "http://atom.github.io/interval-skip-list",
  "keywords": [
    "data-structures",
    "collections",
    "intervals"
  ],
  "author": {
    "name": "Nathan Sobo"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/atom/interval-skip-list/raw/master/LICENSE.md"
    }
  ],
  "dependencies": {
    "underscore-plus": "^1.6.6"
  },
  "devDependencies": {
    "coffee-script": "~1.6.3",
    "jasmine-focused": "~0.12.0",
    "grunt-contrib-coffee": "~0.7.0",
    "grunt-cli": "~0.1.8",
    "grunt": "~0.4.1",
    "grunt-shell": "~0.2.2",
    "grunt-coffeelint": "0.0.6",
    "rimraf": "~2.2.2"
  },
  "readme": "# Interval Skip List [![Build Status](https://travis-ci.org/atom/interval-skip-list.png)](https://travis-ci.org/atom/interval-skip-list)\n\nThis data structure maps intervals to values and allows you to find all\nintervals that contain an index in `O(ln(n))`, where `n` is the number of\nintervals stored. This implementation is based on the paper\n[The Interval Skip List](https://www.cise.ufl.edu/tr/DOC/REP-1992-45.pdf) by\nEric N. Hanson.\n\n## Basic Usage Example\n\n```coffee\nIntervalSkipList = require 'interval-skip-list'\nlist = new IntervalSkipList\n\nlist.insert('a', 2, 7)\nlist.insert('b', 1, 5)\nlist.insert('c', 8, 8)\n\nlist.findContaining(1) # => ['b']\nlist.findContaining(2) # => ['b', 'a']\nlist.findContaining(8) # => ['c']\n\nlist.remove('b')\n\nlist.findContaining(2) # => ['a']\n```\n\n## API\n\n* `::insert(label, startIndex, endIndex)`\n  Adds an interval with the given unique label to the list.\n\n* `::remove(label)`\n  Removes the interval with the given unique label from the list.\n\n* `::update(label, startIndex, endIndex)`\n  Inserts or updates the interval corresponding to the given unique label.\n  Unlike `::insert`, this method allows you to specify a label that's already\n  been inserted in the list.\n\n* `::findContaining(indices...)`\n  Returns the labels of all intervals containing the given indices.\n\n* `::findIntersecting(indices...)`\n  Returns the labels of all intervals intersecting the given set of indices.\n  Unlike `::findContaining`, this method does not require that the intervals\n  contain *all* the given indices.\n\n* `::findStartingAt(index)`\n  Returns the labels of all intervals starting at the given index.\n\n* `::findEndingAt(index)`\n  Returns the labels of all intervals ending at the given index.\n\n* `::findStartingIn(startIndex, endIndex)`\n  Returns the labels of all intervals starting within the interval described by\n  the given start and end indices.\n\n* `::findEndingIn(startIndex, endIndex)`\n  Returns the labels of all intervals ending within the interval described by\n  the given start and end indices.\n\n## Using a Custom Comparator\n\nYou can also supply a custom comparator function with corresponding min and max\nindex values. The following example uses arrays expressing coordinate pairs\ninstead of the default numeric values:\n\n```coffee\nlist = new IntervalSkipList\n  minIndex: [-Infinity, -Infinity]\n  maxIndex: [Infinity, Infinity]\n  compare: (a, b) ->\n    if a[0] < b[0]\n      -1\n    else if a[0] > b[0]\n      1\n    else\n      if a[1] < b[1]\n        -1\n      else if a[1] > b[1]\n        1\n      else\n        0\n\n  list.insert(\"a\", [1, 2], [3, 4])\n  list.insert(\"b\", [2, 1], [3, 10])\n  list.findContaining([1, Infinity]) # => [\"a\"]\n  list.findContaining([2, 20]) # => [\"a\", \"b\"]\n```\n",
  "readmeFilename": "README.md",
  "_id": "interval-skip-list@2.0.1",
  "_from": "interval-skip-list@^2.0.1"
}
