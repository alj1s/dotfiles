{
  "name": "alt",
  "version": "0.12.3",
  "description": "A flux implementation",
  "main": "dist/alt.js",
  "dependencies": {
    "es-symbol": "^1.0.1",
    "eventemitter3": "^0.1.6",
    "flux": "^2.0.1",
    "object-assign": "^2.0.0"
  },
  "devDependencies": {
    "6to5": "^3.5.3",
    "coveralls": "^2.11.2",
    "istanbul": "^0.3.5",
    "mocha": "^2.1.0"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/goatslacker/alt.git"
  },
  "scripts": {
    "build": "npm run build-alt; npm run build-alt-runtime",
    "build-alt": "6to5 ./src/alt.js > dist/alt.js",
    "build-alt-runtime": "6to5 --runtime src/alt.js > dist/alt-with-runtime.js",
    "build-test": "6to5 --runtime test/index.js > test/compiled.js",
    "coverage": "istanbul cover _mocha -- -u exports -R list test/compiled.js",
    "prepublish": "npm test",
    "test": "npm run build; npm run build-test; npm run tests-all",
    "tests-all": "mocha -u exports -R list test/compiled.js"
  },
  "keywords": [
    "flux",
    "react",
    "flow",
    "unidirectional"
  ],
  "author": {
    "name": "Josh Perez",
    "email": "josh@goatslacker.com"
  },
  "license": "MIT",
  "readme": "# alt\n\n[![Gitter](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/goatslacker/alt?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\n> To alter. Altered; Changed.\n\n[![NPM version](https://badge.fury.io/js/alt.svg)](http://badge.fury.io/js/alt)\n[![Build Status](https://secure.travis-ci.org/goatslacker/alt.svg)](http://travis-ci.org/goatslacker/alt)\n[![Coverage Status](https://img.shields.io/coveralls/goatslacker/alt.svg?style=flat)](https://coveralls.io/r/goatslacker/alt)\n[![Dependency Status](https://david-dm.org/goatslacker/alt.svg)](https://david-dm.org/goatslacker/alt)\n[![Download Count](https://img.shields.io/npm/dm/alt.svg?style=flat)](https://www.npmjs.com/package/alt)\n\n\nIf you're in a hurry [show me the code](#examples) or [tl;dr](#tldr).\n\nAlt is a [flux](http://facebook.github.io/flux/docs/overview.html) implementation that is [small](https://github.com/goatslacker/alt/blob/master/src/alt.js) (~4.3kb & 400 LOC), [well tested](https://github.com/goatslacker/alt/blob/master/test.js), [terse](https://github.com/goatslacker/alt#differences), [insanely flexible](#flexibility), and [forward thinking](#es6).\n\nSome boilerplate has been removed from flux such as the [JS \"constants\"](https://github.com/facebook/flux/blob/master/examples/flux-chat/js/constants/ChatConstants.js),\nthe [static string tossing](https://github.com/facebook/flux/blob/master/examples/flux-chat/js/dispatcher/ChatAppDispatcher.js#L39),\nand the [massive switch statements](https://github.com/facebook/flux/blob/master/examples/flux-chat/js/stores/MessageStore.js#L111) you're required to code.\n\nAlt is pure flux though. Data flows one way. Here's an ascii chart to prove it.\n\n```txt\n      ╔═══════════════╗             ╔══════════════╗             ╔════════════╗\n      ║    Actions    ║  ═══════>   ║    Stores    ║  ═══════>   ║    View    ║\n      ╚═══════════════╝             ╚══════════════╝             ╚════════════╝\n              ▲                                                        ║\n              ║                                                        ║\n              ╚════════════════════════════════════════════════════════╝\n```\n\n## What the flux?\n\nFor those new to Flux in general here's a short overview: Flux eschews MVC in favor of unidirectional data flow. What this means is that data\nenters through your actions which are then sent to the stores whose responsibility is to manage state and dependencies of that state, and then finally\nthe store informs the view via event listeners so the view can update. The view then triggers more actions via user input and the flow restarts.\n\n## Pure flux\n\nAlt is a terse implementation of Flux that encourages unadulterated flux and all the nice ideas that come along with it:\n\n* The Flux [dispatcher](https://github.com/facebook/flux/blob/master/src/Dispatcher.js), which\nmeans one can only dispatch one action per cycle to ensure a predictable and simple data flow (rather than cascading actions).\nThe `waitFor` method is also available to help you marshall callback order.\n\n* Store uses an event emitter, in our case [EventEmitter3](https://github.com/primus/EventEmitter3), so\none can set up the view to listen to changes on the store.\n\n* Singleton stores making your store logic simple to follow and easy to test.\n\n* Single dispatcher which allows one to listen to all events for debugging or fun.\n\n## Differences\n\nSome boilerplate has been removed from flux.\n\nThere is no giant switch statement you have to write in your store and this is because alt removes the burden of constants from the developer.\nThis has the wonderful side effect of making the custom dispatcher logic unnecessary, thus removing one of the boxes from the flow\nchart (not pictured above) the dispatcher.\n\nMake no mistake, there is still a single dispatcher through which actions flow through on their merry way to the store, in fact, you still get the benefit of being able to hook into the dispatcher to listen to all the global events for debugging, fun, or misery.\nThe dispatcher is just a part of alt and something you don't necessarily have to write custom code for.\n\nThese removals make the code terse and easy to follow, there is less indirection and the learning curve to grok is much lower.\nThink I'm lying? [Check out an example](#differences-example).\n\n## Additions\n\nWhat's new.\n\nOne really cool aspect of alt is that you can save snapshots of the entire application's state at any given point in time.\nBest of all, if you really screw the state up beyond repair you can easily rollback to the last saved snapshot.\n\nThere's also a method available that lets you bootstrap all the application's stores once, at startup, with a saved snapshot.\nThis is particularly useful if you're writing isomorphic applications where you can send down a snapshot of the state the server was in, then bootstrap it back on the client and continue working where the program left off.\n\nStores are immutable. Meaning you can't just update the store through your store instance, the objects returned by `getState` are immutable (well you can mutate them all you want but it won't affect the state inside the store), and other stores can't mutate other stores. This makes it easy to reason about how your application exactly changes and where.\n\nLast but not least, alt is meant to work with ES6. That is we're betting you'll be writing your stores and actions\nas classes. This part isn't necessary but you really should write some ES6 anyways because it's nice.\n\n## Usage\n\n### Installing\n\n```sh\nnpm install alt\n```\n\n### Running tests\n\nCheck out the repo and then:\n\n```sh\nnpm test\n```\n\n### Actually Using It\n\nWe'll be referring back to this code a lot by using the `alt` variable declared.\n\n```js\nvar Alt = require('alt')\nvar alt = new Alt()\n```\n\n### ES6\n\nAlt is written in, and encourages ES6. It is completely optional but it is pleasant to write.\n\nYou can use the es6 transpiler that comes with react courtesy of\n[jstransform](https://github.com/facebook/jstransform) or you can use one of the other popular ES6 transpilers:\n[6to5](https://6to5.org/) or [traceur](https://github.com/google/traceur-compiler).\n\nYou won't need an [es6-shim](https://github.com/paulmillr/es6-shim) but you can use one for further goodies in your javascripts.\n\nAlt does depend on ES5 features, the good news is so does React. You can use [es5-shim](https://github.com/es-shims/es5-shim)\nto support those pesky old browsers.\n\n### Creating Actions\n\nActions are the way you update state. They're kind of a big deal.\n\n`alt.createActions :: Class -> Actions`\n\n```js\nclass LocationActions {\n  updateLocation() {\n    this.dispatch('Paris')\n  }\n}\n\nvar locationActions = alt.createActions(LocationActions)\n```\n\nEvery action contains a `dispatch` method which is what sends your data to the dispatcher for dispatching to stores. The type signature for dispatch is `dispatch :: x -> undefined`.\n\n`alt.createActions` then returns an `Object` containing all the methods defined. You can then call your actions directly.\n\n```js\nlocationActions.updateLocation()\n```\n\nYou can also define actions that take a parameter like so\n\n```js\nclass LocationActions {\n  updateLocation(x) {\n    this.dispatch(x)\n  }\n}\n\nvar locationActions = alt.createActions(LocationActions)\n```\n\n```js\nlocationActions.updateLocation('San Francisco')\n```\n\nWriting out actions that pass data through directly can get quite tedious so there's a shorthand for writing these what are essentially `identity` functions\n\n```js\nclass LocationActions {\n  constructor() {\n    // for single action\n    this.generateActions('updateLocation')\n\n    // as well as for many actions\n    this.generateActions('updateCity', 'updateState', 'updateCountry')\n  }\n}\n\nvar locationActions = alt.createActions(LocationActions)\n```\n\n```js\nlocationActions.updateLocation('Las Vegas')\n\nlocationActions.updateCity('Las Vegas')\nlocationActions.updateState('Nevada')\nlocationActions.updateCountry('US')\n```\n\nRemember, `dispatch` only takes one argument. Therefore, if you need to pass multiple arguments into a store you can use an Object.\n\n```js\nclass LocationActions {\n  updateLocation(x, y) {\n    this.dispatch({ x, y })\n  }\n}\n\nvar locationActions = alt.createActions(LocationActions)\n\nlocationActions.updateLocation('Miami', 'Florida')\n```\n\nAn shorthand function created in the constructor will pass through the multiple parameters as an Array\n\n```js\nclass LocationActions {\n  constructor() {\n    this.generateActions('updateLocation') // ['South Lake Tahoe, 'California']\n  }\n}\n\nvar locationActions = alt.createActions(LocationActions)\n\nlocationActions.updateLocation('South Lake Tahoe', 'California')\n```\n\n### Stores\n\nStores are where you keep a part of your application's state. It's a singleton, holds your data, and is immutable.\n\n`alt.createStore :: Class, String -> Store`\n\n```js\nclass LocationStore {\n  constructor() {\n    this.bindAction(locationActions.updateLocation, this.onUpdateLocation)\n\n    this.city = 'Denver'\n    this.state = 'Colorado'\n  }\n\n  onUpdateLocation(obj) {\n    var { city, state } = obj\n    this.city = city\n    this.state = state\n  }\n}\n\nvar locationStore = alt.createStore(LocationStore)\n```\n\nStores require a constructor, that's where you'll set your initial state and bind any actions to the methods that update the state, the `action handlers` if you will. All store instances returned by `alt.createStore` will have the following methods:\n\n#### createStore API\n\n##### listen :: Function -> undefined\n\n`listen` is meant to be used by your View components in order to await changes made to each store.\n\n```js\nlocationStore.listen((data) => {\n  console.log(data)\n})\n```\n\n##### unlisten :: Function -> undefined\n\n`unlisten` is a clean up method. It takes in the same function you used for `listen` and unregisters it.\n\n##### getState :: State\n\n`getState` will return a copy of your the current store's state.\n\n```js\nlocationStore.getState().city === 'Denver'\n```\n\n##### dispatcherToken\n\nA token that can be used with waitFor.\n\n#### Important Note\n\nAll defined methods in your Store class **will not** be available on the store instance. They are accessible within the class but not on the returned\nObject via `alt.createStore`. This ensures that stores have no direct setters and the state remains mutable only through actions keeping the flow unidirectional.\nIf you want to attach public/static functions to your store you may do so as a static method on the class itself.\n\n```js\nclass LocationStore {\n  static myPublicMethod() {\n    var internalInstanceState = this.getState()\n    return internalInstanceState\n  }\n}\n\nvar locationStore = alt.createStore(LocationStore)\n\nlocationStore.myPublicMethod()\n```\n\n#### Canceling An Event\n\nIf you don't want the store to inform the view of an action make sure to return false\nfrom the action handler methods, alt won't judge you.\n\n```js\nclass LocationStore {\n  constructor() {\n    this.bindAction(locationActions.updateCity, this.onUpdateCity)\n\n    this.city = 'Portland'\n    this.state = 'Oregon'\n  }\n\n  onUpdateCity(city) {\n    this.city = city\n\n    // ensure the view never finds out\n    return false\n  }\n}\n\nvar locationStore = alt.createStore(LocationStore)\n```\n\n#### Constants\n\nI thought you said there were no constants? Well, yeah, sort of. The thing is, they're automagically created for you.\nFeel free to use them to bind your actions or use the method itself, whatever reads better in your opinion.\n\n```js\nclass LocationStore {\n  constructor() {\n    this.bindAction(locationActions.UPDATE_STATE, this.onUpdateState)\n\n    this.city = ''\n    this.state = ''\n  }\n}\n\nvar locationStore = alt.createStore(LocationStore)\n```\n\nConstants are automagically generated for you so feel free to use them to bind your actions or use the method itself, whatever reads better in your opinion.\n\n#### Listening To Multiple Actions\n\nIn the ~~rare~~ very common case of binding multiple actions, calling `bindAction` with each\nhandler is not anyone's idea of fun.\n\n```js\nclass LocationActions {\n  constructor() {\n    this.generateActions('updateCity', 'updateState')\n  }\n}\n\nvar locationActions = alt.createActions(LocationActions)\n```\n\nYou can bind all the actions inside `locationActions` using the shortcut `bindActions`\n\n```js\nclass LocationStore {\n  constructor() {\n    this.bindActions(locationActions)\n\n    this.city = 'Austin'\n    this.state = 'Texas'\n  }\n\n  onUpdateCity(city) {\n    this.city = city\n  }\n\n  onUpdateState(state) {\n    this.state = state\n  }\n}\n\nvar locationStore = alt.createStore(LocationStore)\n```\n\nActions who have a `onCamelCasedAction` method or an `actionName` method available in the store will be bound.\n\n#### Methods available in Stores\n\nThus brings us to our final store point. Stores have the following available methods internally:\n\n* `on :: lifecycleMethod, handler -> undefined`\n* `bindAction :: ActionsMethod, StoreMethod -> undefined`\n* `bindActions :: Actions -> undefined`\n* `waitFor :: DispatcherToken | [DispatcherTokens] -> undefined`\n\n`waitFor` is mostly an alias to Flux's Dispatcher waitFor. Here's an excerpt from the flux docs on what waitFor is designed for:\n\n> As an application grows, dependencies across different stores are a near certainty. Store A will inevitably need Store B to update itself first, so that Store A can know how to update itself. We need the dispatcher to be able to invoke the callback for Store B, and finish that callback, before moving forward with Store A. To declaratively assert this dependency, a store needs to be able to say to the dispatcher, \"I need to wait for Store B to finish processing this action.\" The dispatcher provides this functionality through its waitFor() method.\n\nYou can use waitFor like so:\n\n```js\nvar dependingStore = alt.createStore(class DependingStore {\n  constructor() {\n    this.bindActions(someActions)\n    this.data = 42\n  }\n\n  onRandom(x) {\n    this.data = x\n  }\n})\n\nvar locationStore = alt.createStore(class LocationStore {\n  constructor() {\n    this.bindActions(someOtherActions)\n\n    this.syncedData = Date.now()\n  }\n\n  onThings() {\n    this.waitFor(dependingStore.dispatchToken)\n    this.syncedData = dependingStore.getState().data\n  }\n})\n```\n\nYou can also `waitFor` multiple stores by passing in an Array: `this.waitFor([store1.dispatchToken, store2.dispatchToken])`\n\n### Views\n\nYour choice of view isn't important to alt. What's important is to know how the view consumes the store's data, and that is via event listeners.\n\nIn this example I'll be using React, but you're free to use your library of choice.\n\n```js\nvar LocationComponent = React.createClass({\n  getInitialState() {\n    return locationStore.getState()\n  },\n\n  componentWillMount() {\n    locationStore.listen(this.onChange)\n  },\n\n  componentWillUnmount() {\n    locationStore.unlisten(this.onChange)\n  },\n\n  onChange() {\n    this.setState(this.getInitialState())\n  },\n\n  render() {\n    return (\n      <div>\n        <p>\n          City {this.state.city}\n        </p>\n        <p>\n          State {this.state.state}\n        </p>\n      </div>\n    )\n  }\n})\n```\n\nAlt provides a free `ListenerMixin` for React so you don't have to remember to unregister your listener. You can use said mixin like this:\n\n```js\nvar ListenerMixin = require('alt/ListenerMixin')\n\nvar LocationComponent = React.createClass({\n  mixins: [ListenerMixin],\n\n  getInitialState() {\n    return locationStore.getState()\n  },\n\n  componentWillMount() {\n    this.listenTo(locationStore, this.onChange)\n  },\n\n  onChange() {\n    this.setState(this.getInitialState())\n  },\n\n  render() {\n    return (\n      <div>\n        <p>\n          City {this.state.city}\n        </p>\n        <p>\n          State {this.state.state}\n        </p>\n      </div>\n    )\n  }\n})\n```\n\n### Full Circle\n\nRestart the loop by making your views kick off new actions.\n\n## Alt Features\n\n### Snapshots\n\n`takeSnapshot :: String`\n\nSnapshots are a core component of alt. The idea is that at any given point in time you can `takeSnapshot` and have your entire application's state\nserialized for persistence, transfering, logging, or debugging.\n\nTaking a snapshot is as easy as calling `alt.takeSnapshot()`.\n\n### Bootstrapping\n\n`bootstrap :: String -> undefined`\n\nBootstrapping can only be done once, and usually is best to do when initializing your application. The `alt.bootstrap()` function takes in a snapshot\nyou've saved and reloads all the state with that snapshot, no events will be emitted to your components during this process, so again, it's best to do this\non init before the view has even rendered.\n\nBootstrap is great if you're running an isomorphic app, or if you're persisting state to localstorage and then retrieving it on init later on. You can save a snapshot on the server side, send it down, and then bootstrap it back on the client.\n\nIf you're bootstrapping then it is recommended you pass in a unique Identifier, name of the class is good enough, to createStore so that it can be referenced later for bootstrapping.\n\n```js\nalt.createStore(LocationStore, 'LocationStore')\n```\n\n### Rollback\n\n`rollback :: undefined`\n\nIf you've screwed up the state, or you just feel like rolling back you can call `alt.rollback()`. Rollback is pretty dumb in the sense\nthat it's not automatic in case of errors, and it only rolls back to the last saved snapshot, meaning you have to save a snapshot first in order to roll back.\n\n### Flushing\n\n`flush :: String`\n\nFlush takes a snapshot of the current state and then resets all the stores back to their original initial state. This is useful if you're using alt stores as singletons and doing server side rendering because of concurrency. In this particular scenario you would load the data in via `bootstrap` and then use `flush` to take a snapshot, render the data, and reset your stores so they are ready for the next request.\n\n### Recycling\n\n`recycle :: ?...String -> undefined`\n\nIf you wish to reset a particular, or all, store's state back to their original initial state you would call `recycle`. Recycle takes an optional number of arguments as strings which correspond to the store's names you would like reset. If no argument is provided then all stores are reset.\n\n### Life Cycle Methods\n\nWhen bootstrapping, snapshotting, or recycling there are special methods you can assign to your store to ensure any bookeeping that needs to be done. You would place these in your store's constructor.\n\n`bootstrap` is called after the store has been bootstrapped. Here you can add some logic to take your bootstrapped data and manipulate it.\n\n```js\nclass Store {\n  constructor() {\n    this.on('bootstrap', () => {\n      // do something here\n    })\n  }\n}\n```\n\n`snapshot` is called before the store's state is serialized. Here you can perform any final tasks you need to before the state is saved.\n\n```js\nclass Store {\n  constructor() {\n    this.on('snapshot', () => {\n      // do something here\n    })\n  }\n}\n```\n\n`init` is called when the store is initialized as well as whenever a store is recycled.\n\n```js\nclass Store {\n  constructor() {\n    this.on('init', () => {\n      // do something here\n    })\n  }\n}\n```\n\n`rollback` is called whenever all the stores are rolled back.\n\n```js\nclass Store {\n  constructor() {\n    this.on('rollback', () => {\n      // do something here\n    })\n  }\n}\n```\n\n### Single Dispatcher\n\nA single dispatcher instance is made available for listening to all events passing through. You can access this via the `dispatcher` property: `alt.dispatcher`\nand listening to all events is as easy as\n\n```js\nalt.dispatcher.register(console.log)\n```\n\nEach store has a reference to the dispatcher as well\n\n```js\nalt.createStore(class MyStore {\n  constructor() {\n    this.dispatcher.register(console.log)\n  }\n})\n```\n\n### Flexibility\n\nYou can choose to use alt in many ways just like you'd use flux. This means your asynchronous data fetching can live in the actions, or they can live in the stores.\nStores may also be traditional singletons as in flux, or you can create an instance and have multilple store copies. This leads us into server side rendering.\n\n### Server Side Rendering\n\nAlt was built with isomorphism in mind. This means that you can run full flux server-side and pick back up on the client-side.\n\nThere are two options for using flux on the server:\n\n* Keep stores as singletons, keep data loading synchronous, bootstrap, and flush.\n* Create multiple instances of flux and inject the context into your app.\n\n#### Stores as Singletons\n\nWith this approach your stores are singletons.\nAny actions that load data must be synchronous, meaning you can fetch your data outside of actions and stores, and once done you fire off a synchronous action which loads\nthe store. Alternatively, you can gather all of your data, and once complete, you call `bootstrap()` which seeds all the stores with some initial data.\n\nOnce you've completed loading the stores with data you call `flush()` which takes a snapshot to send to the client and then resets all the stores' state back to their initial state. This allows the stores to be ready for the next server request.\n\n#### Flux Instances\n\nIf you're afraid of singletons, or if you want to skip synchronous actions or data loading you may want to create separate instances of flux for every server request. Taking this approach means you're making the trade-off of injecting the flux instance into your application in order to retrieve the stores and use the actions. This approach is similar to how [fluxible](https://github.com/yahoo/fluxible) solves isomorphic applications. Creating a new alt instances is fairly simple.\n\n```js\nclass Flux extends Alt {\n  constructor() {\n    super()\n\n    this.addActions('myActions', ActionCreators)\n    this.addStore('storeName', Store)\n  }\n}\n\nvar flux = new Flux()\n\n// sample using react...\nReact.render(\n  <App flux={flux} />,\n  document.body\n)\n\n// retrieving stores\nflux.getStore('storeName').getState()\n\n// actions\nflux.getActions('myActions')\n```\n\n#### Picking back up on the client\n\nTo help facilitate with isomorphism alt recommends you use [iso](https://github.com/goatslacker/iso), a helper function which serializes the data on the server into markup and then parses that data back into usable JavaScript on the client. Iso is a great complement to alt for a full-stack flux approach.\n\n## Examples\n\n* [todomvc](https://github.com/goatslacker/alt/blob/master/examples/todomvc)\n* [chat](https://github.com/goatslacker/alt/tree/master/examples/chat)\n\n## Converting a flux application to alt\n\n1. [Importing the chat project](https://github.com/goatslacker/alt/commit/1a54de1064fe5bd252979380e47b0409d1306773).\n2. [Adding alt and removing boilerplate](https://github.com/goatslacker/alt/commit/75ffdb53420dc32bdc2d99b5cf534cd0949331d8).\n3. [Converting some actions](https://github.com/goatslacker/alt/commit/6f8cf22ba6b36c6ae91a794fad75473c9436b683) and [the last action](https://github.com/goatslacker/alt/commit/58ea1418ecd2af25b578cd0f4b77c3d4d8631518).\n4. Converting the stores [MessageStore](https://github.com/goatslacker/alt/commit/f4c7bb4bb9027b53c380f98ed99a2e1b6ba5fa0b), [ThreadStore](https://github.com/goatslacker/alt/commit/bce2aadbb52981f934b4281b3a6244d4f2c4a7a9), and [UnreadThreadStore](https://github.com/goatslacker/alt/commit/0129baa5bd505ef26228e30cfa15a6ac4503a22d).\n5. [Finishing touches](https://github.com/goatslacker/alt/commit/e05a4e02f3f13831361136a21cd757416b69b4d8).\n\n## Differences Example\n\nFlux has constants, the dispatcher is also pretty dumb as in it just takes what you passed in the action\nand pipes it through to the store. This is completely fine but not something you should be expected to write.\nThe nice thing about constants is that you can easily grep for them in your application and see where\nall the actions are being called, with alt you get the same benefit without having to manage them.\n\n#### Before: Flux\n\n```js\nvar keyMirror = require('keymirror')\n\nvar actionConstants = keyMirror({\n  HANDLE_ACTION: null\n})\n\nvar action = {\n  foo() {\n    AppDispatcher.handleAction({ type: actionConstants.HANDLE_ACTION, data: 'foo' })\n  }\n}\n\nvar AppDispatcher = Object.assign(new Dispatcher(), {\n  handleAction(payload) {\n    this.dispatch(payload)\n  }\n})\n```\n\n#### After: Alt\n\n```js\nclass Action {\n  handleAction() {\n    this.dispatch('foo')\n  }\n}\n\nvar action = alt.createActions(Action)\n```\n\n## TL;DR\n\n* Isomorphic\n* Pure Flux\n* No constants\n* No static string checking\n* No giant switch statement\n* Save state snapshots\n* Rollbacks\n* Bootstrap components on app load\n* Light-weight and terse\n* ES6 Syntax, code your actions and stores with classes\n* Flexible\n* Immutable stores\n* Single dispatcher\n* Global listening for debugging\n* Small library\n\n## License\n\n[![MIT](https://img.shields.io/npm/l/alt.svg?style=flat)](http://josh.mit-license.org)\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/goatslacker/alt/issues"
  },
  "homepage": "https://github.com/goatslacker/alt",
  "_id": "alt@0.12.3",
  "_from": "alt@^0.12.0"
}
