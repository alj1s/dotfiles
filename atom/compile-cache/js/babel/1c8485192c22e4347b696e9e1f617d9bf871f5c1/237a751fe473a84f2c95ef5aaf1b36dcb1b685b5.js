var TypeAssertPropertyAccessToType = (function () {
    function TypeAssertPropertyAccessToType() {
        this.key = TypeAssertPropertyAccessToType.name;
    }
    TypeAssertPropertyAccessToType.prototype.canProvideFix = function (info) {
        var relevantError = info.positionErrors.filter(function (x) {
            return x.code == ts.Diagnostics.Property_0_does_not_exist_on_type_1.code;
        })[0];
        if (!relevantError) return;
        if (info.positionNode.kind !== 66) return;
        var match = getIdentifierName(info.positionErrorMessages[0]);
        if (!match) return;
        var identifierName = match.identifierName;
        return { display: "Assert <Type> for property access \"" + identifierName + "\"", isNewTextSnippet: true };
    };
    TypeAssertPropertyAccessToType.prototype.provideFix = function (info) {
        var parent = info.positionNode.parent;
        if (parent.kind == 163) {
            var propertyAccess = parent;
            var start = propertyAccess.getStart();
            var end = propertyAccess.dotToken.getStart();
            var oldText = propertyAccess.getText().substr(0, end - start);
            var refactoring = {
                filePath: info.filePath,
                span: {
                    start: start,
                    length: propertyAccess.name.end - start
                },
                newText: "(" + oldText + " as ${1:any})${2:." + propertyAccess.name.getText() + "}${3}",
                isNewTextSnippet: true
            };
            return [refactoring];
        }
        return [];
    };
    return TypeAssertPropertyAccessToType;
})();
exports.TypeAssertPropertyAccessToType = TypeAssertPropertyAccessToType;
function getIdentifierName(errorText) {
    var match = /Property \'(\w+)\' does not exist on type \.*/.exec(errorText);
    if (!match) return;
    var identifierName = match[1];
    return { identifierName: identifierName };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbmRyZXdqb25lcy8uYXRvbS9wYWNrYWdlcy9hdG9tLXR5cGVzY3JpcHQvZGlzdC9tYWluL2xhbmcvZml4bXl0cy9xdWlja0ZpeGVzL3R5cGVBc3NlcnRQcm9wZXJ0eUFjY2Vzc1RvVHlwZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxJQUFJLDhCQUE4QixHQUFHLENBQUMsWUFBWTtBQUM5QyxhQUFTLDhCQUE4QixHQUFHO0FBQ3RDLFlBQUksQ0FBQyxHQUFHLEdBQUcsOEJBQThCLENBQUMsSUFBSSxDQUFDO0tBQ2xEO0FBQ0Qsa0NBQThCLENBQUMsU0FBUyxDQUFDLGFBQWEsR0FBRyxVQUFVLElBQUksRUFBRTtBQUNyRSxZQUFJLGFBQWEsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsRUFBRTtBQUFFLG1CQUFPLENBQUMsQ0FBQyxJQUFJLElBQUksRUFBRSxDQUFDLFdBQVcsQ0FBQyxtQ0FBbUMsQ0FBQyxJQUFJLENBQUM7U0FBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDOUksWUFBSSxDQUFDLGFBQWEsRUFDZCxPQUFPO0FBQ1gsWUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksS0FBSyxFQUFFLEVBQzdCLE9BQU87QUFDWCxZQUFJLEtBQUssR0FBRyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMscUJBQXFCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUM3RCxZQUFJLENBQUMsS0FBSyxFQUNOLE9BQU87QUFDWCxZQUFJLGNBQWMsR0FBRyxLQUFLLENBQUMsY0FBYyxDQUFDO0FBQzFDLGVBQU8sRUFBRSxPQUFPLEVBQUUsc0NBQXNDLEdBQUcsY0FBYyxHQUFHLElBQUksRUFBRSxnQkFBZ0IsRUFBRSxJQUFJLEVBQUUsQ0FBQztLQUM5RyxDQUFDO0FBQ0Ysa0NBQThCLENBQUMsU0FBUyxDQUFDLFVBQVUsR0FBRyxVQUFVLElBQUksRUFBRTtBQUNsRSxZQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQztBQUN0QyxZQUFJLE1BQU0sQ0FBQyxJQUFJLElBQUksR0FBRyxFQUFFO0FBQ3BCLGdCQUFJLGNBQWMsR0FBRyxNQUFNLENBQUM7QUFDNUIsZ0JBQUksS0FBSyxHQUFHLGNBQWMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztBQUN0QyxnQkFBSSxHQUFHLEdBQUcsY0FBYyxDQUFDLFFBQVEsQ0FBQyxRQUFRLEVBQUUsQ0FBQztBQUM3QyxnQkFBSSxPQUFPLEdBQUcsY0FBYyxDQUFDLE9BQU8sRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsR0FBRyxHQUFHLEtBQUssQ0FBQyxDQUFDO0FBQzlELGdCQUFJLFdBQVcsR0FBRztBQUNkLHdCQUFRLEVBQUUsSUFBSSxDQUFDLFFBQVE7QUFDdkIsb0JBQUksRUFBRTtBQUNGLHlCQUFLLEVBQUUsS0FBSztBQUNaLDBCQUFNLEVBQUUsY0FBYyxDQUFDLElBQUksQ0FBQyxHQUFHLEdBQUcsS0FBSztpQkFDMUM7QUFDRCx1QkFBTyxFQUFFLEdBQUcsR0FBRyxPQUFPLEdBQUcsb0JBQW9CLEdBQUcsY0FBYyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsR0FBRyxPQUFPO0FBQ3ZGLGdDQUFnQixFQUFFLElBQUk7YUFDekIsQ0FBQztBQUNGLG1CQUFPLENBQUMsV0FBVyxDQUFDLENBQUM7U0FDeEI7QUFDRCxlQUFPLEVBQUUsQ0FBQztLQUNiLENBQUM7QUFDRixXQUFPLDhCQUE4QixDQUFDO0NBQ3pDLENBQUEsRUFBRyxDQUFDO0FBQ0wsT0FBTyxDQUFDLDhCQUE4QixHQUFHLDhCQUE4QixDQUFDO0FBQ3hFLFNBQVMsaUJBQWlCLENBQUMsU0FBUyxFQUFFO0FBQ2xDLFFBQUksS0FBSyxHQUFHLCtDQUErQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUM1RSxRQUFJLENBQUMsS0FBSyxFQUNOLE9BQU87QUFDWCxRQUFJLGNBQWMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDOUIsV0FBTyxFQUFFLGNBQWMsRUFBRSxjQUFjLEVBQUUsQ0FBQztDQUM3QyIsImZpbGUiOiIvVXNlcnMvYW5kcmV3am9uZXMvLmF0b20vcGFja2FnZXMvYXRvbS10eXBlc2NyaXB0L2Rpc3QvbWFpbi9sYW5nL2ZpeG15dHMvcXVpY2tGaXhlcy90eXBlQXNzZXJ0UHJvcGVydHlBY2Nlc3NUb1R5cGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgVHlwZUFzc2VydFByb3BlcnR5QWNjZXNzVG9UeXBlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUeXBlQXNzZXJ0UHJvcGVydHlBY2Nlc3NUb1R5cGUoKSB7XG4gICAgICAgIHRoaXMua2V5ID0gVHlwZUFzc2VydFByb3BlcnR5QWNjZXNzVG9UeXBlLm5hbWU7XG4gICAgfVxuICAgIFR5cGVBc3NlcnRQcm9wZXJ0eUFjY2Vzc1RvVHlwZS5wcm90b3R5cGUuY2FuUHJvdmlkZUZpeCA9IGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICAgIHZhciByZWxldmFudEVycm9yID0gaW5mby5wb3NpdGlvbkVycm9ycy5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguY29kZSA9PSB0cy5EaWFnbm9zdGljcy5Qcm9wZXJ0eV8wX2RvZXNfbm90X2V4aXN0X29uX3R5cGVfMS5jb2RlOyB9KVswXTtcbiAgICAgICAgaWYgKCFyZWxldmFudEVycm9yKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoaW5mby5wb3NpdGlvbk5vZGUua2luZCAhPT0gNjYpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBtYXRjaCA9IGdldElkZW50aWZpZXJOYW1lKGluZm8ucG9zaXRpb25FcnJvck1lc3NhZ2VzWzBdKTtcbiAgICAgICAgaWYgKCFtYXRjaClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGlkZW50aWZpZXJOYW1lID0gbWF0Y2guaWRlbnRpZmllck5hbWU7XG4gICAgICAgIHJldHVybiB7IGRpc3BsYXk6IFwiQXNzZXJ0IDxUeXBlPiBmb3IgcHJvcGVydHkgYWNjZXNzIFxcXCJcIiArIGlkZW50aWZpZXJOYW1lICsgXCJcXFwiXCIsIGlzTmV3VGV4dFNuaXBwZXQ6IHRydWUgfTtcbiAgICB9O1xuICAgIFR5cGVBc3NlcnRQcm9wZXJ0eUFjY2Vzc1RvVHlwZS5wcm90b3R5cGUucHJvdmlkZUZpeCA9IGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBpbmZvLnBvc2l0aW9uTm9kZS5wYXJlbnQ7XG4gICAgICAgIGlmIChwYXJlbnQua2luZCA9PSAxNjMpIHtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eUFjY2VzcyA9IHBhcmVudDtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHByb3BlcnR5QWNjZXNzLmdldFN0YXJ0KCk7XG4gICAgICAgICAgICB2YXIgZW5kID0gcHJvcGVydHlBY2Nlc3MuZG90VG9rZW4uZ2V0U3RhcnQoKTtcbiAgICAgICAgICAgIHZhciBvbGRUZXh0ID0gcHJvcGVydHlBY2Nlc3MuZ2V0VGV4dCgpLnN1YnN0cigwLCBlbmQgLSBzdGFydCk7XG4gICAgICAgICAgICB2YXIgcmVmYWN0b3JpbmcgPSB7XG4gICAgICAgICAgICAgICAgZmlsZVBhdGg6IGluZm8uZmlsZVBhdGgsXG4gICAgICAgICAgICAgICAgc3Bhbjoge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aDogcHJvcGVydHlBY2Nlc3MubmFtZS5lbmQgLSBzdGFydCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG5ld1RleHQ6IFwiKFwiICsgb2xkVGV4dCArIFwiIGFzICR7MTphbnl9KSR7MjouXCIgKyBwcm9wZXJ0eUFjY2Vzcy5uYW1lLmdldFRleHQoKSArIFwifSR7M31cIixcbiAgICAgICAgICAgICAgICBpc05ld1RleHRTbmlwcGV0OiB0cnVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBbcmVmYWN0b3JpbmddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuICAgIHJldHVybiBUeXBlQXNzZXJ0UHJvcGVydHlBY2Nlc3NUb1R5cGU7XG59KSgpO1xuZXhwb3J0cy5UeXBlQXNzZXJ0UHJvcGVydHlBY2Nlc3NUb1R5cGUgPSBUeXBlQXNzZXJ0UHJvcGVydHlBY2Nlc3NUb1R5cGU7XG5mdW5jdGlvbiBnZXRJZGVudGlmaWVyTmFtZShlcnJvclRleHQpIHtcbiAgICB2YXIgbWF0Y2ggPSAvUHJvcGVydHkgXFwnKFxcdyspXFwnIGRvZXMgbm90IGV4aXN0IG9uIHR5cGUgXFwuKi8uZXhlYyhlcnJvclRleHQpO1xuICAgIGlmICghbWF0Y2gpXG4gICAgICAgIHJldHVybjtcbiAgICB2YXIgaWRlbnRpZmllck5hbWUgPSBtYXRjaFsxXTtcbiAgICByZXR1cm4geyBpZGVudGlmaWVyTmFtZTogaWRlbnRpZmllck5hbWUgfTtcbn1cbiJdfQ==