'use babel';
/* @flow */

/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

var path = require('path');

/**
 * This function returns HgRepositoryDescription filled with a repoPath and
 * originURL iff it finds that the given directory is within an Hg repository.
 */
function findHgRepository(directoryPath) {
  var fs = require('fs-plus');
  var workingDirectoryPath = directoryPath;
  var repoPath = null;
  var originURL = null;
  /*eslint-disable no-constant-condition */
  while (true) {
    var dirToTest = path.join(workingDirectoryPath, '.hg');
    if (fs.isDirectorySync(dirToTest) && fs.isFileSync(path.join(dirToTest, 'hgrc'))) {
      var ini = require('ini');
      // I'm not quite sure why this header is required, but I copied this
      // from the npm page to make things work: https://www.npmjs.com/package/ini.
      var header = 'scope = global\n';
      var config = ini.parse(header + fs.readFileSync(path.join(dirToTest, 'hgrc')));
      if (typeof config.paths['default'] === 'string') {
        repoPath = dirToTest;
        originURL = config.paths['default'];
        break;
      }
    }

    if (isRootDir(workingDirectoryPath)) {
      break;
    } else {
      workingDirectoryPath = getParentDir(workingDirectoryPath);
    }
  }
  /*eslint-enable no-constant-condition */
  return { repoPath: repoPath, originURL: originURL, workingDirectoryPath: workingDirectoryPath };
}

function isRootDir(directoryPath) {
  var isRoot = require('nuclide-commons').fsPromise.isRoot;

  return isRoot(directoryPath);
}

function getParentDir(directoryPath) {
  return path.resolve(directoryPath, '..');
}

module.exports = findHgRepository;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbmRyZXdqb25lcy8uYXRvbS9wYWNrYWdlcy9udWNsaWRlLWhnLXJlcG9zaXRvcnkvbm9kZV9tb2R1bGVzL251Y2xpZGUtc291cmNlLWNvbnRyb2wtaGVscGVycy9saWIvaGctcmVwb3NpdG9yeS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxXQUFXLENBQUM7Ozs7Ozs7Ozs7O0FBV1osSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDOzs7Ozs7QUFZM0IsU0FBUyxnQkFBZ0IsQ0FBQyxhQUFxQixFQUEyQjtBQUN4RSxNQUFJLEVBQUUsR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7QUFDNUIsTUFBSSxvQkFBb0IsR0FBRyxhQUFhLENBQUM7QUFDekMsTUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDO0FBQ3BCLE1BQUksU0FBUyxHQUFHLElBQUksQ0FBQzs7QUFFckIsU0FBTyxJQUFJLEVBQUU7QUFDWCxRQUFJLFNBQVMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLG9CQUFvQixFQUFFLEtBQUssQ0FBQyxDQUFDO0FBQ3ZELFFBQUksRUFBRSxDQUFDLGVBQWUsQ0FBQyxTQUFTLENBQUMsSUFDN0IsRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxNQUFNLENBQUMsQ0FBQyxFQUFFO0FBQy9DLFVBQUksR0FBRyxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQzs7O0FBR3pCLFVBQUksTUFBTSxHQUFHLGtCQUFrQixDQUFDO0FBQ2hDLFVBQUksTUFBTSxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUN6QixFQUFFLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNuRCxVQUFJLE9BQU8sTUFBTSxDQUFDLEtBQUssV0FBUSxLQUFLLFFBQVEsRUFBRTtBQUM1QyxnQkFBUSxHQUFHLFNBQVMsQ0FBQztBQUNyQixpQkFBUyxHQUFHLE1BQU0sQ0FBQyxLQUFLLFdBQVEsQ0FBQztBQUNqQyxjQUFNO09BQ1A7S0FDRjs7QUFFRCxRQUFJLFNBQVMsQ0FBQyxvQkFBb0IsQ0FBQyxFQUFFO0FBQ25DLFlBQU07S0FDUCxNQUFNO0FBQ0wsMEJBQW9CLEdBQUcsWUFBWSxDQUFDLG9CQUFvQixDQUFDLENBQUM7S0FDM0Q7R0FDRjs7QUFFRCxTQUFPLEVBQUMsUUFBUSxFQUFSLFFBQVEsRUFBRSxTQUFTLEVBQVQsU0FBUyxFQUFFLG9CQUFvQixFQUFwQixvQkFBb0IsRUFBQyxDQUFDO0NBQ3BEOztBQUVELFNBQVMsU0FBUyxDQUFDLGFBQXFCLEVBQVc7TUFDNUMsTUFBTSxHQUFJLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLFNBQVMsQ0FBOUMsTUFBTTs7QUFDWCxTQUFPLE1BQU0sQ0FBQyxhQUFhLENBQUMsQ0FBQztDQUM5Qjs7QUFFRCxTQUFTLFlBQVksQ0FBQyxhQUFxQixFQUFVO0FBQ25ELFNBQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLEVBQUUsSUFBSSxDQUFDLENBQUM7Q0FDMUM7O0FBRUQsTUFBTSxDQUFDLE9BQU8sR0FBRyxnQkFBZ0IsQ0FBQyIsImZpbGUiOiIvVXNlcnMvYW5kcmV3am9uZXMvLmF0b20vcGFja2FnZXMvbnVjbGlkZS1oZy1yZXBvc2l0b3J5L25vZGVfbW9kdWxlcy9udWNsaWRlLXNvdXJjZS1jb250cm9sLWhlbHBlcnMvbGliL2hnLXJlcG9zaXRvcnkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGJhYmVsJztcbi8qIEBmbG93ICovXG5cbi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgbGljZW5zZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluXG4gKiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcblxudHlwZSBIZ1JlcG9zaXRvcnlEZXNjcmlwdGlvbiA9IHtcbiAgcmVwb1BhdGg6ID9zdHJpbmc7XG4gIG9yaWdpblVSTDogP3N0cmluZztcbiAgd29ya2luZ0RpcmVjdG9yeVBhdGg6IHN0cmluZztcbn07XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiByZXR1cm5zIEhnUmVwb3NpdG9yeURlc2NyaXB0aW9uIGZpbGxlZCB3aXRoIGEgcmVwb1BhdGggYW5kXG4gKiBvcmlnaW5VUkwgaWZmIGl0IGZpbmRzIHRoYXQgdGhlIGdpdmVuIGRpcmVjdG9yeSBpcyB3aXRoaW4gYW4gSGcgcmVwb3NpdG9yeS5cbiAqL1xuZnVuY3Rpb24gZmluZEhnUmVwb3NpdG9yeShkaXJlY3RvcnlQYXRoOiBzdHJpbmcpOiBIZ1JlcG9zaXRvcnlEZXNjcmlwdGlvbiB7XG4gIHZhciBmcyA9IHJlcXVpcmUoJ2ZzLXBsdXMnKTtcbiAgdmFyIHdvcmtpbmdEaXJlY3RvcnlQYXRoID0gZGlyZWN0b3J5UGF0aDtcbiAgdmFyIHJlcG9QYXRoID0gbnVsbDtcbiAgdmFyIG9yaWdpblVSTCA9IG51bGw7XG4gIC8qZXNsaW50LWRpc2FibGUgbm8tY29uc3RhbnQtY29uZGl0aW9uICovXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIGRpclRvVGVzdCA9IHBhdGguam9pbih3b3JraW5nRGlyZWN0b3J5UGF0aCwgJy5oZycpO1xuICAgIGlmIChmcy5pc0RpcmVjdG9yeVN5bmMoZGlyVG9UZXN0KSAmJlxuICAgICAgICBmcy5pc0ZpbGVTeW5jKHBhdGguam9pbihkaXJUb1Rlc3QsICdoZ3JjJykpKSB7XG4gICAgICB2YXIgaW5pID0gcmVxdWlyZSgnaW5pJyk7XG4gICAgICAvLyBJJ20gbm90IHF1aXRlIHN1cmUgd2h5IHRoaXMgaGVhZGVyIGlzIHJlcXVpcmVkLCBidXQgSSBjb3BpZWQgdGhpc1xuICAgICAgLy8gZnJvbSB0aGUgbnBtIHBhZ2UgdG8gbWFrZSB0aGluZ3Mgd29yazogaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvaW5pLlxuICAgICAgdmFyIGhlYWRlciA9ICdzY29wZSA9IGdsb2JhbFxcbic7XG4gICAgICB2YXIgY29uZmlnID0gaW5pLnBhcnNlKGhlYWRlciArXG4gICAgICAgICAgZnMucmVhZEZpbGVTeW5jKHBhdGguam9pbihkaXJUb1Rlc3QsICdoZ3JjJykpKTtcbiAgICAgIGlmICh0eXBlb2YgY29uZmlnLnBhdGhzLmRlZmF1bHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJlcG9QYXRoID0gZGlyVG9UZXN0O1xuICAgICAgICBvcmlnaW5VUkwgPSBjb25maWcucGF0aHMuZGVmYXVsdDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzUm9vdERpcih3b3JraW5nRGlyZWN0b3J5UGF0aCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICB3b3JraW5nRGlyZWN0b3J5UGF0aCA9IGdldFBhcmVudERpcih3b3JraW5nRGlyZWN0b3J5UGF0aCk7XG4gICAgfVxuICB9XG4gIC8qZXNsaW50LWVuYWJsZSBuby1jb25zdGFudC1jb25kaXRpb24gKi9cbiAgcmV0dXJuIHtyZXBvUGF0aCwgb3JpZ2luVVJMLCB3b3JraW5nRGlyZWN0b3J5UGF0aH07XG59XG5cbmZ1bmN0aW9uIGlzUm9vdERpcihkaXJlY3RvcnlQYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgdmFyIHtpc1Jvb3R9ID0gcmVxdWlyZSgnbnVjbGlkZS1jb21tb25zJykuZnNQcm9taXNlO1xuICByZXR1cm4gaXNSb290KGRpcmVjdG9yeVBhdGgpO1xufVxuXG5mdW5jdGlvbiBnZXRQYXJlbnREaXIoZGlyZWN0b3J5UGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHBhdGgucmVzb2x2ZShkaXJlY3RvcnlQYXRoLCAnLi4nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kSGdSZXBvc2l0b3J5O1xuIl19